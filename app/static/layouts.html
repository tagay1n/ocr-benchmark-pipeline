<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Layout Review</title>
    <style>
      :root {
        --bg: #f3f1eb;
        --surface: #fffdf7;
        --ink: #1e1f1c;
        --muted: #63635f;
        --accent: #0b7a75;
        --danger: #a52222;
        --border: #e0dccf;
        --actions-col-size: 7ch;
        --class-col-size: 16ch;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "IBM Plex Sans", "Segoe UI", sans-serif;
        color: var(--ink);
        background:
          radial-gradient(circle at 100% 0, #d6ebe7 0, transparent 30%),
          radial-gradient(circle at 0 100%, #f7e3cf 0, transparent 32%),
          var(--bg);
      }

      main {
        width: 100%;
        padding: 24px;
      }

      .header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }

      h1 {
        margin: 0;
        font-size: 26px;
      }

      .subline {
        color: var(--muted);
      }

      .actions {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      .detect-controls {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
      }

      .detect-controls label {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        font-size: 13px;
        color: var(--muted);
      }

      .detect-controls input {
        width: 84px;
      }

      button,
      a.button-link {
        border: 1px solid var(--accent);
        background: var(--accent);
        color: #fff;
        border-radius: 10px;
        padding: 8px 12px;
        font-weight: 600;
        cursor: pointer;
        text-decoration: none;
      }

      button.secondary {
        background: #fff;
        color: var(--accent);
      }

      a.button-link.secondary {
        background: #fff;
        color: var(--accent);
      }

      button.danger {
        border-color: var(--danger);
        background: var(--danger);
      }

      .row-actions {
        display: inline-flex;
        flex-direction: column;
        align-items: stretch;
        gap: 4px;
        width: 100%;
      }

      .icon-btn {
        width: 100%;
        min-width: 0;
        height: var(--actions-col-size);
        padding: 0;
        line-height: 1;
        font-size: 16px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }

      .grid {
        margin-top: 16px;
        display: grid;
        grid-template-columns: minmax(0, 1fr) fit-content(100%);
        gap: 16px;
        align-items: start;
      }

      .panel {
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 14px;
      }

      .layouts-panel {
        width: fit-content;
        max-width: 100%;
      }

      .layouts-panel table {
        width: auto;
      }

      .layouts-panel th,
      .layouts-panel td {
        white-space: nowrap;
      }

      .layout-class-select {
        width: 100%;
      }

      .layout-class-col {
        width: var(--class-col-size);
        min-width: var(--class-col-size);
      }

      .layout-order-col {
        width: 5ch;
      }

      .layout-actions-col {
        width: var(--actions-col-size);
        min-width: var(--actions-col-size);
      }

      .layout-order-input {
        width: 100%;
        min-width: 0;
        padding: 4px;
        text-align: right;
      }

      .layout-bbox-cell {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      .bbox-field {
        display: inline-flex;
        align-items: center;
        gap: 3px;
        font-size: 12px;
        color: var(--muted);
      }

      .bbox-label {
        min-width: 18px;
      }

      .layout-bbox-input {
        width: 76px;
      }

      .image-wrap {
        position: relative;
        width: 100%;
        border: 1px solid var(--border);
        border-radius: 10px;
        overflow: hidden;
        background: #f7f5ef;
      }

      #page-image {
        display: block;
        width: 100%;
        height: auto;
      }

      #overlay {
        position: absolute;
        inset: 0;
      }

      .box {
        position: absolute;
        border: 2px solid #0b7a75;
        background: rgba(11, 122, 117, 0.12);
        border-radius: 4px;
      }

      .box-label {
        position: absolute;
        top: -20px;
        left: 0;
        font-size: 12px;
        background: rgba(255, 253, 247, 0.92);
        color: #1e1f1c;
        border: 1px solid #cfc8b7;
        border-radius: 6px;
        padding: 2px 6px;
        white-space: nowrap;
      }

      table {
        width: 100%;
        border-collapse: collapse;
      }

      th,
      td {
        border-bottom: 1px solid var(--border);
        text-align: left;
        padding: 8px 6px;
        vertical-align: top;
      }

      th {
        font-size: 13px;
        color: var(--muted);
      }

      input {
        width: 100%;
        padding: 6px;
        border: 1px solid var(--border);
        border-radius: 8px;
      }

      select {
        width: 100%;
        padding: 6px;
        border: 1px solid var(--border);
        border-radius: 8px;
        background: #fff;
      }

      .status-line {
        margin-top: 8px;
        color: var(--muted);
      }

      .error {
        color: var(--danger);
      }

      @media (max-width: 980px) {
        .grid {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <main>
      <section class="header">
        <div>
          <h1>Layout Review</h1>
          <div id="page-meta" class="subline"></div>
        </div>
        <div class="actions">
          <a class="button-link secondary" href="/">Back to Dashboard</a>
          <div class="detect-controls">
            <label>
              Conf
              <input id="detect-conf" type="number" min="0" max="1" step="0.01" value="0.25" />
            </label>
            <label>
              IoU
              <input id="detect-iou" type="number" min="0" max="1" step="0.01" value="0.45" />
            </label>
          </div>
          <button id="detect-btn" type="button">Redetect Layouts</button>
          <button id="add-btn" class="secondary" type="button">Add Box</button>
          <button id="review-btn" type="button">Mark Reviewed</button>
          <button id="review-next-btn" class="secondary" type="button" disabled>Review</button>
        </div>
      </section>

      <section class="grid">
        <article class="panel">
          <div class="image-wrap">
            <img id="page-image" alt="Page for layout review" />
            <div id="overlay"></div>
          </div>
          <div id="status-line" class="status-line"></div>
        </article>

        <article class="panel layouts-panel">
          <h2>Layouts</h2>
          <table>
            <thead>
                <tr>
                  <th class="layout-class-col">Class</th>
                  <th class="layout-order-col">Order</th>
                  <th>BBox</th>
                  <th class="layout-actions-col">Actions</th>
                </tr>
              </thead>
            <tbody id="layouts-body"></tbody>
          </table>
        </article>
      </section>
    </main>

    <script type="module">
      const params = new URLSearchParams(window.location.search);
      const pageId = Number(params.get("page_id"));
      const STORAGE_KEYS = {
        detectConf: "layout.detect_conf",
        detectIou: "layout.detect_iou",
        layoutDraftPrefix: "layout.draft.page",
      };

      function readStorage(key) {
        try {
          return window.localStorage.getItem(key);
        } catch {
          return null;
        }
      }

      function writeStorage(key, value) {
        try {
          window.localStorage.setItem(key, value);
        } catch {
          // Ignore storage errors (private mode / quota / disabled storage).
        }
      }

      function removeStorage(key) {
        try {
          window.localStorage.removeItem(key);
        } catch {
          // Ignore storage errors (private mode / quota / disabled storage).
        }
      }

      const pageMeta = document.getElementById("page-meta");
      const pageImage = document.getElementById("page-image");
      const overlay = document.getElementById("overlay");
      const statusLine = document.getElementById("status-line");
      const layoutsBody = document.getElementById("layouts-body");

      const detectBtn = document.getElementById("detect-btn");
      const addBtn = document.getElementById("add-btn");
      const reviewBtn = document.getElementById("review-btn");
      const reviewNextBtn = document.getElementById("review-next-btn");
      const detectConfInput = document.getElementById("detect-conf");
      const detectIouInput = document.getElementById("detect-iou");

      const state = {
        page: null,
        layouts: [],
        serverLayoutsById: {},
        localEditsById: {},
        deletedLayoutIds: new Set(),
      };

      function applyStoredDetectThresholds() {
        const storedConf = readStorage(STORAGE_KEYS.detectConf);
        const storedIou = readStorage(STORAGE_KEYS.detectIou);

        if (storedConf !== null) {
          const parsedConf = Number(storedConf);
          if (!Number.isNaN(parsedConf) && parsedConf >= 0 && parsedConf <= 1) {
            detectConfInput.value = storedConf;
          }
        }
        if (storedIou !== null) {
          const parsedIou = Number(storedIou);
          if (!Number.isNaN(parsedIou) && parsedIou >= 0 && parsedIou <= 1) {
            detectIouInput.value = storedIou;
          }
        }
      }

      function draftStorageKey() {
        return `${STORAGE_KEYS.layoutDraftPrefix}:${pageId}`;
      }

      function toDraftShape(layout) {
        return {
          class_name: normalizeClassName(layout.class_name) || "text",
          reading_order: layout.reading_order === null ? null : Number(layout.reading_order),
          bbox: {
            x1: roundTo4(layout.bbox.x1),
            y1: roundTo4(layout.bbox.y1),
            x2: roundTo4(layout.bbox.x2),
            y2: roundTo4(layout.bbox.y2),
          },
        };
      }

      function sameDraft(a, b) {
        return (
          a.class_name === b.class_name &&
          a.reading_order === b.reading_order &&
          a.bbox.x1 === b.bbox.x1 &&
          a.bbox.y1 === b.bbox.y1 &&
          a.bbox.x2 === b.bbox.x2 &&
          a.bbox.y2 === b.bbox.y2
        );
      }

      function parseStoredDraft(rawDraft) {
        if (!rawDraft || typeof rawDraft !== "object") {
          return null;
        }

        const className = normalizeClassName(rawDraft.class_name);
        if (!className) {
          return null;
        }

        const readingOrderRaw = rawDraft.reading_order;
        let readingOrder = null;
        if (readingOrderRaw !== null) {
          const parsed = Number(readingOrderRaw);
          if (!Number.isInteger(parsed) || parsed < 1) {
            return null;
          }
          readingOrder = parsed;
        }

        const bbox = rawDraft.bbox;
        if (!bbox || typeof bbox !== "object") {
          return null;
        }

        const x1 = roundTo4(bbox.x1);
        const y1 = roundTo4(bbox.y1);
        const x2 = roundTo4(bbox.x2);
        const y2 = roundTo4(bbox.y2);
        if ([x1, y1, x2, y2].some((value) => Number.isNaN(value) || value < 0 || value > 1)) {
          return null;
        }

        return {
          class_name: className,
          reading_order: readingOrder,
          bbox: { x1, y1, x2, y2 },
        };
      }

      function loadLayoutDraftState() {
        state.localEditsById = {};
        state.deletedLayoutIds = new Set();

        const raw = readStorage(draftStorageKey());
        if (!raw) {
          return;
        }

        let parsed;
        try {
          parsed = JSON.parse(raw);
        } catch {
          return;
        }
        if (!parsed || typeof parsed !== "object") {
          return;
        }

        const edits = parsed.edits;
        if (edits && typeof edits === "object") {
          for (const [key, value] of Object.entries(edits)) {
            const id = Number(key);
            if (!Number.isInteger(id) || id <= 0) {
              continue;
            }
            const draft = parseStoredDraft(value);
            if (!draft) {
              continue;
            }
            state.localEditsById[String(id)] = draft;
          }
        }

        if (Array.isArray(parsed.deleted_ids)) {
          for (const rawId of parsed.deleted_ids) {
            const id = Number(rawId);
            if (Number.isInteger(id) && id > 0) {
              state.deletedLayoutIds.add(id);
              delete state.localEditsById[String(id)];
            }
          }
        }
      }

      function persistLayoutDraftState() {
        const payload = {
          edits: state.localEditsById,
          deleted_ids: Array.from(state.deletedLayoutIds).sort((a, b) => a - b),
        };
        writeStorage(draftStorageKey(), JSON.stringify(payload));
      }

      function clearLayoutDraftState() {
        state.localEditsById = {};
        state.deletedLayoutIds = new Set();
        removeStorage(draftStorageKey());
      }

      const CLASS_COLORS = {
        title: "#8f4b63",
        section_header: "#355fa8",
        text: "#4f5d69",
        list_item: "#2f6f5f",
        table: "#6f7d2f",
        picture: "#8a6831",
        caption: "#496f98",
        footnote: "#7a6030",
        formula: "#7b5a95",
        page_header: "#3f6e69",
        page_footer: "#8b5949",
      };

      const KNOWN_LAYOUT_CLASSES = [
        "title",
        "section_header",
        "text",
        "list_item",
        "table",
        "picture",
        "caption",
        "footnote",
        "formula",
        "page_header",
        "page_footer",
      ];

      const FALLBACK_COLORS = ["#4e6f8f", "#7c5f90", "#3f7b69", "#8d6a3b", "#82605b", "#537987", "#6e6b3f"];

      function hashString(value) {
        let hash = 0;
        for (let i = 0; i < value.length; i += 1) {
          hash = (hash << 5) - hash + value.charCodeAt(i);
          hash |= 0;
        }
        return Math.abs(hash);
      }

      function colorForClass(className) {
        const normalized = String(className || "")
          .trim()
          .toLowerCase()
          .replace(/[-/\s]+/g, "_");
        if (CLASS_COLORS[normalized]) {
          return CLASS_COLORS[normalized];
        }
        return FALLBACK_COLORS[hashString(normalized) % FALLBACK_COLORS.length];
      }

      function hexToRgba(hex, alpha) {
        const clean = hex.replace("#", "");
        const r = Number.parseInt(clean.slice(0, 2), 16);
        const g = Number.parseInt(clean.slice(2, 4), 16);
        const b = Number.parseInt(clean.slice(4, 6), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
      }

      function setStatus(message, { isError = false } = {}) {
        statusLine.textContent = message;
        statusLine.classList.toggle("error", isError);
      }

      async function fetchJson(url, options) {
        const response = await fetch(url, options);
        const payload = await response.json().catch(() => ({}));
        if (!response.ok) {
          const detail = payload && payload.detail ? payload.detail : `Request failed: ${response.status}`;
          throw new Error(detail);
        }
        return payload;
      }

      function toFixed(value) {
        return Number(value).toFixed(4);
      }

      function roundTo4(value) {
        return Math.round(Number(value) * 10000) / 10000;
      }

      function boxStyle(layout) {
        const { x1, y1, x2, y2 } = layout.bbox;
        return {
          left: `${x1 * 100}%`,
          top: `${y1 * 100}%`,
          width: `${(x2 - x1) * 100}%`,
          height: `${(y2 - y1) * 100}%`,
        };
      }

      function readingOrderSortValue(layout) {
        const value = Number(layout.reading_order);
        if (Number.isInteger(value) && value >= 1) {
          return value;
        }
        return Number.MAX_SAFE_INTEGER;
      }

      function sortLayoutsInPlace() {
        state.layouts.sort((a, b) => {
          const orderCmp = readingOrderSortValue(a) - readingOrderSortValue(b);
          if (orderCmp !== 0) {
            return orderCmp;
          }
          return Number(a.id) - Number(b.id);
        });
      }

      function renderOverlay() {
        overlay.innerHTML = "";
        for (const layout of state.layouts) {
          const color = colorForClass(layout.class_name);
          const box = document.createElement("div");
          box.className = "box";
          const style = boxStyle(layout);
          box.style.left = style.left;
          box.style.top = style.top;
          box.style.width = style.width;
          box.style.height = style.height;
          box.style.borderColor = color;
          box.style.background = hexToRgba(color, 0.16);

          const label = document.createElement("div");
          label.className = "box-label";
          label.style.color = color;
          label.style.borderColor = hexToRgba(color, 0.62);
          label.textContent = `${layout.reading_order}. ${layout.class_name}`;
          box.appendChild(label);
          overlay.appendChild(box);
        }
      }

      function formatClassLabel(className) {
        return String(className)
          .replace(/_/g, " ")
          .replace(/\b\w/g, (m) => m.toUpperCase());
      }

      function normalizeClassName(className) {
        return String(className || "")
          .trim()
          .toLowerCase()
          .replace(/[-/\s]+/g, "_");
      }

      function buildClassSelect(initialClass) {
        const select = document.createElement("select");
        const normalizedInitial = normalizeClassName(initialClass);
        const classes = [...KNOWN_LAYOUT_CLASSES];
        if (normalizedInitial && !classes.includes(normalizedInitial)) {
          classes.unshift(normalizedInitial);
        }

        for (const className of classes) {
          const option = document.createElement("option");
          option.value = className;
          option.textContent = formatClassLabel(className);
          select.appendChild(option);
        }

        select.value = normalizedInitial || "text";
        return select;
      }

      function applyClassColorToSelect(select, className) {
        const color = colorForClass(className);
        select.style.borderColor = hexToRgba(color, 0.55);
        select.style.color = color;
      }

      function layoutRow(layout) {
        const tr = document.createElement("tr");
        const layoutId = Number(layout.id);
        const serverLayout = state.serverLayoutsById[String(layoutId)];
        const serverBaseline = serverLayout ? toDraftShape(serverLayout) : toDraftShape(layout);

        const classTd = document.createElement("td");
        classTd.className = "layout-class-col";
        const classInput = buildClassSelect(layout.class_name);
        classInput.classList.add("layout-class-select");
        applyClassColorToSelect(classInput, layout.class_name);
        classTd.appendChild(classInput);
        tr.appendChild(classTd);

        const orderTd = document.createElement("td");
        orderTd.className = "layout-order-col";
        const orderInput = document.createElement("input");
        orderInput.type = "number";
        orderInput.min = "1";
        orderInput.step = "1";
        orderInput.className = "layout-order-input";
        orderInput.value = layout.reading_order === null ? "" : String(layout.reading_order);
        orderTd.appendChild(orderInput);
        tr.appendChild(orderTd);

        const bboxTd = document.createElement("td");
        bboxTd.className = "layout-bbox-cell";
        const bboxSpec = [
          ["x1", "x1"],
          ["y1", "y1"],
          ["x2", "x2"],
          ["y2", "y2"],
        ];
        const bboxFields = bboxSpec.map(([key, labelText]) => {
          const input = document.createElement("input");
          input.type = "number";
          input.min = "0";
          input.max = "1";
          input.step = "0.001";
          input.className = "layout-bbox-input";
          input.value = toFixed(layout.bbox[key]);
          const field = document.createElement("label");
          field.className = "bbox-field";
          const label = document.createElement("span");
          label.className = "bbox-label";
          label.textContent = labelText;
          field.appendChild(label);
          field.appendChild(input);
          return [key, input, field];
        });
        for (const [, , field] of bboxFields) {
          bboxTd.appendChild(field);
        }
        tr.appendChild(bboxTd);

        function applyDraftToInputs(draft) {
          classInput.value = draft.class_name;
          applyClassColorToSelect(classInput, draft.class_name);
          orderInput.value = draft.reading_order === null ? "" : String(draft.reading_order);
          bboxFields[0][1].value = toFixed(draft.bbox.x1);
          bboxFields[1][1].value = toFixed(draft.bbox.y1);
          bboxFields[2][1].value = toFixed(draft.bbox.x2);
          bboxFields[3][1].value = toFixed(draft.bbox.y2);
        }

        function parseReadingOrder(rawValue) {
          const raw = String(rawValue).trim();
          if (raw === "") {
            return null;
          }
          const value = Number(raw);
          if (!Number.isInteger(value) || value < 1) {
            throw new Error("Reading order must be an integer >= 1.");
          }
          return value;
        }

        function parseBoundedNumber(rawValue) {
          const value = roundTo4(rawValue);
          if (Number.isNaN(value) || value < 0 || value > 1) {
            throw new Error("BBox values must be between 0 and 1.");
          }
          return value;
        }

        function payloadFromInputs() {
          const className = normalizeClassName(classInput.value) || "text";
          return {
            class_name: className,
            reading_order: parseReadingOrder(orderInput.value),
            bbox: {
              x1: parseBoundedNumber(bboxFields[0][1].value),
              y1: parseBoundedNumber(bboxFields[1][1].value),
              x2: parseBoundedNumber(bboxFields[2][1].value),
              y2: parseBoundedNumber(bboxFields[3][1].value),
            },
          };
        }

        function replaceLayoutInState(updatedLayout) {
          const idx = state.layouts.findIndex((row) => row.id === updatedLayout.id);
          if (idx >= 0) {
            state.layouts[idx] = updatedLayout;
            renderOverlay();
          }
        }

        function applyDraftToState(draft) {
          replaceLayoutInState({
            ...layout,
            id: layoutId,
            class_name: draft.class_name,
            reading_order: draft.reading_order,
            bbox: { ...draft.bbox },
          });
        }

        function saveLocalDraft() {
          let draft;
          try {
            draft = payloadFromInputs();
          } catch (error) {
            setStatus(`Draft not saved: ${error.message}`, { isError: true });
            return false;
          }

          applyDraftToState(draft);
          if (sameDraft(draft, serverBaseline)) {
            delete state.localEditsById[String(layoutId)];
            state.deletedLayoutIds.delete(layoutId);
            setStatus("Draft cleared (matches original).");
          } else {
            state.localEditsById[String(layoutId)] = draft;
            state.deletedLayoutIds.delete(layoutId);
            setStatus("Draft saved locally.");
          }
          persistLayoutDraftState();
          return true;
        }

        classInput.addEventListener("change", () => {
          applyClassColorToSelect(classInput, classInput.value);
          saveLocalDraft();
        });
        orderInput.addEventListener("change", () => {
          const previousOrder = Number.isInteger(Number(layout.reading_order))
            ? Number(layout.reading_order)
            : null;
          if (saveLocalDraft()) {
            const currentLayout = state.layouts.find((row) => Number(row.id) === layoutId);
            const nextOrder =
              currentLayout && Number.isInteger(Number(currentLayout.reading_order))
                ? Number(currentLayout.reading_order)
                : null;
            let swapped = false;

            if (previousOrder !== null && nextOrder !== null && previousOrder !== nextOrder) {
              const conflict = state.layouts.find(
                (row) => Number(row.id) !== layoutId && Number(row.reading_order) === nextOrder,
              );
              if (conflict) {
                const conflictId = Number(conflict.id);
                const conflictDraft = toDraftShape(conflict);
                conflictDraft.reading_order = previousOrder;

                conflict.class_name = conflictDraft.class_name;
                conflict.reading_order = conflictDraft.reading_order;
                conflict.bbox = { ...conflictDraft.bbox };

                const conflictServer = state.serverLayoutsById[String(conflictId)];
                const conflictBaseline = conflictServer ? toDraftShape(conflictServer) : conflictDraft;
                if (sameDraft(conflictDraft, conflictBaseline)) {
                  delete state.localEditsById[String(conflictId)];
                } else {
                  state.localEditsById[String(conflictId)] = conflictDraft;
                }
                state.deletedLayoutIds.delete(conflictId);
                persistLayoutDraftState();
                swapped = true;
              }
            }

            renderLayouts();
            if (swapped) {
              setStatus("Draft saved locally. Order swapped.");
            }
          }
        });
        for (const [, input] of bboxFields) {
          input.addEventListener("change", () => {
            const parsed = Number(input.value);
            if (!Number.isNaN(parsed)) {
              input.value = toFixed(roundTo4(parsed));
            }
            saveLocalDraft();
          });
        }

        const actionsTd = document.createElement("td");
        actionsTd.className = "layout-actions-col";
        const actionsWrap = document.createElement("div");
        actionsWrap.className = "row-actions";

        const restoreBtn = document.createElement("button");
        restoreBtn.className = "secondary icon-btn";
        restoreBtn.type = "button";
        restoreBtn.title = "Restore values";
        restoreBtn.setAttribute("aria-label", "Restore values");
        restoreBtn.textContent = "â†º";
        restoreBtn.addEventListener("click", () => {
          applyDraftToInputs(serverBaseline);
          applyDraftToState(serverBaseline);
          delete state.localEditsById[String(layoutId)];
          state.deletedLayoutIds.delete(layoutId);
          persistLayoutDraftState();
          renderLayouts();
          setStatus("Layout values restored.");
        });
        actionsWrap.appendChild(restoreBtn);

        const deleteBtn = document.createElement("button");
        deleteBtn.className = "danger icon-btn";
        deleteBtn.type = "button";
        deleteBtn.title = "Delete layout";
        deleteBtn.setAttribute("aria-label", "Delete layout");
        deleteBtn.textContent = "ðŸ—‘";
        deleteBtn.addEventListener("click", () => {
          state.deletedLayoutIds.add(layoutId);
          delete state.localEditsById[String(layoutId)];
          persistLayoutDraftState();
          state.layouts = state.layouts.filter((row) => Number(row.id) !== layoutId);
          renderLayouts();
          setStatus("Layout marked for deletion. It will be deleted after review.");
        });
        actionsWrap.appendChild(deleteBtn);

        actionsTd.appendChild(actionsWrap);
        tr.appendChild(actionsTd);
        return tr;
      }

      function renderLayouts() {
        sortLayoutsInPlace();
        layoutsBody.innerHTML = "";
        for (const layout of state.layouts) {
          layoutsBody.appendChild(layoutRow(layout));
        }
        renderOverlay();
      }

      async function loadPage() {
        const payload = await fetchJson(`/api/pages/${pageId}`);
        state.page = payload.page;
        pageMeta.textContent = `Page #${state.page.id} | ${state.page.rel_path} | status: ${state.page.status}`;
        pageImage.src = payload.image_url;
      }

      async function loadLayouts() {
        const payload = await fetchJson(`/api/pages/${pageId}/layouts`);
        state.serverLayoutsById = {};
        for (const layout of payload.layouts) {
          state.serverLayoutsById[String(layout.id)] = layout;
        }

        const mergedLayouts = [];
        for (const layout of payload.layouts) {
          const layoutId = Number(layout.id);
          if (state.deletedLayoutIds.has(layoutId)) {
            continue;
          }

          const draft = state.localEditsById[String(layoutId)];
          if (!draft) {
            mergedLayouts.push(layout);
            continue;
          }
          mergedLayouts.push({
            ...layout,
            class_name: draft.class_name,
            reading_order: draft.reading_order,
            bbox: { ...draft.bbox },
          });
        }

        for (const key of Object.keys(state.localEditsById)) {
          if (!(key in state.serverLayoutsById)) {
            delete state.localEditsById[key];
          }
        }
        for (const layoutId of Array.from(state.deletedLayoutIds)) {
          if (!(String(layoutId) in state.serverLayoutsById)) {
            state.deletedLayoutIds.delete(layoutId);
          }
        }

        state.layouts = mergedLayouts;
        persistLayoutDraftState();
        renderLayouts();
      }

      async function refreshNextReviewButton() {
        try {
          const payload = await fetchJson(`/api/pages/${pageId}/layout-review-next`);
          if (payload.has_next && Number.isInteger(payload.next_page_id) && payload.next_page_id > 0) {
            reviewNextBtn.disabled = false;
            reviewNextBtn.dataset.nextPageId = String(payload.next_page_id);
            reviewNextBtn.title = `Open next page: ${payload.next_page_rel_path}`;
          } else {
            reviewNextBtn.disabled = true;
            reviewNextBtn.dataset.nextPageId = "";
            reviewNextBtn.title = "No pages are waiting for layout review.";
          }
        } catch {
          reviewNextBtn.disabled = true;
          reviewNextBtn.dataset.nextPageId = "";
          reviewNextBtn.title = "Failed to load next page for review.";
        }
      }

      async function detectLayouts() {
        detectBtn.disabled = true;
        try {
          const confidence = Number(detectConfInput.value);
          const iou = Number(detectIouInput.value);
          if (Number.isNaN(confidence) || confidence < 0 || confidence > 1) {
            throw new Error("Confidence must be between 0 and 1.");
          }
          if (Number.isNaN(iou) || iou < 0 || iou > 1) {
            throw new Error("IoU must be between 0 and 1.");
          }

          const payload = await fetchJson(`/api/pages/${pageId}/layouts/detect`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              replace_existing: true,
              confidence_threshold: confidence,
              iou_threshold: iou,
            }),
          });
          clearLayoutDraftState();
          setStatus(
            `Redetect finished. Created ${payload.created} layouts. Conf=${payload.thresholds.confidence_threshold}, IoU=${payload.thresholds.iou_threshold}.`,
          );
          await loadPage();
          await loadLayouts();
          await refreshNextReviewButton();
        } catch (error) {
          setStatus(`Redetect failed: ${error.message}`, { isError: true });
        } finally {
          detectBtn.disabled = false;
        }
      }

      async function addLayout() {
        addBtn.disabled = true;
        try {
          await fetchJson(`/api/pages/${pageId}/layouts`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              class_name: "text",
              reading_order: null,
              bbox: { x1: 0.1, y1: 0.1, x2: 0.9, y2: 0.2 },
            }),
          });
          setStatus("Manual layout added.");
          await loadPage();
          await loadLayouts();
          await refreshNextReviewButton();
        } catch (error) {
          setStatus(`Add failed: ${error.message}`, { isError: true });
        } finally {
          addBtn.disabled = false;
        }
      }

      async function markReviewed() {
        reviewBtn.disabled = true;
        try {
          const deletedIds = Array.from(state.deletedLayoutIds).sort((a, b) => a - b);
          const editedEntries = Object.entries(state.localEditsById).sort(
            ([a], [b]) => Number(a) - Number(b),
          );

          for (const layoutId of deletedIds) {
            await fetchJson(`/api/layouts/${layoutId}`, { method: "DELETE" });
          }

          for (const [layoutId, draft] of editedEntries) {
            if (state.deletedLayoutIds.has(Number(layoutId))) {
              continue;
            }
            await fetchJson(`/api/layouts/${layoutId}`, {
              method: "PATCH",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(draft),
            });
          }

          const payload = await fetchJson(`/api/pages/${pageId}/layouts/review-complete`, {
            method: "POST",
          });
          clearLayoutDraftState();
          setStatus(
            `Page marked reviewed with ${payload.layout_count} layouts. Applied drafts: ${editedEntries.length}, deletions: ${deletedIds.length}.`,
          );
          await loadPage();
          await loadLayouts();
          await refreshNextReviewButton();
        } catch (error) {
          setStatus(`Mark reviewed failed: ${error.message}`, { isError: true });
        } finally {
          reviewBtn.disabled = false;
        }
      }

      detectBtn.addEventListener("click", detectLayouts);
      addBtn.addEventListener("click", addLayout);
      reviewBtn.addEventListener("click", markReviewed);
      reviewNextBtn.addEventListener("click", () => {
        const nextPageId = Number.parseInt(reviewNextBtn.dataset.nextPageId || "", 10);
        if (Number.isInteger(nextPageId) && nextPageId > 0) {
          window.location.href = `/static/layouts.html?page_id=${nextPageId}`;
        }
      });
      detectConfInput.addEventListener("change", () => {
        writeStorage(STORAGE_KEYS.detectConf, detectConfInput.value);
      });
      detectIouInput.addEventListener("change", () => {
        writeStorage(STORAGE_KEYS.detectIou, detectIouInput.value);
      });

      async function init() {
        if (!Number.isInteger(pageId) || pageId <= 0) {
          setStatus("Missing or invalid page_id query parameter.", { isError: true });
          return;
        }
        try {
          loadLayoutDraftState();
          await loadPage();
          await loadLayouts();
          await refreshNextReviewButton();
          setStatus("Ready.");
        } catch (error) {
          setStatus(`Load failed: ${error.message}`, { isError: true });
        }
      }

      applyStoredDetectThresholds();
      init();
    </script>
  </body>
</html>
